# https://codeforces.com/problemset/problem/327/A

# Основная идея - динамика, но после анализа она свелась к одному проходу по последовательности
# Классная задача, немного кайфанул

def check(seq):
    # mx - текущий максимум во всей таблице
    # base - количество "1" в исходной последовательности, 
    # от него мы отталкиваемся, когда считаем - максимальную сумму при условии, что отрезок "переворота" начнется в элементе item
    # mx_lvl - максимальная сумма, если отрезок "переворота" уже был открыт раньше
    mx, base, mx_lvl = 0, sum(seq), 0
    for item in seq:
        # выбираем максимум: или выгоднее начать новый отрезок, или воспользоваться уже открытым
        lvl = max(base, mx_lvl)
        if item:
            lvl -= 1
        else:
            lvl += 1
        mx = max(mx, lvl)
        mx_lvl = lvl
    return mx


input()
seq = tuple(map(int, input().split()))
print(check(seq))
