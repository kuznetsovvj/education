"""https://codeforces.com/contest/1352/problem/F"""
"""Сложность: 1500"""

"""Для некоторой 01-строки s (то есть такой, что каждый символ si — это либо '0', либо '1') выписали все пары подряд идущих символов (все подстроки длины 2). 
Для каждой пары (подстроки длины 2) посчитали количество символов '1' (единиц) в ней.

Вам заданы три числа:

n0 — количество пар подряд идущих символов (подстрок), в которых 0 единиц;
n1 — количество пар подряд идущих символов (подстрок), в которых 1 единица;
n2 — количество пар подряд идущих символов (подстрок), в которых 2 единицы.
Например, для строки s=«1110011110» были бы выписаны следующие подстроки: «11», «11», «10», «00», «01», «11», «11», «11», «10». 
Таким образом, n0=1, n1=3, n2=5.

Ваша задача — по заданным n0,n1,n2 восстановить любую подходящую 01-строку (бинарную строку) s. 
Гарантируется, что хотя бы одно из чисел n0,n1,n2 отлично от 0. Также гарантируется, что решение существует."""

# Решение

def solution(n0, n1, n2):
    if n1 == 0: # если переходов нет, то это или одни нули, или одни единицы
        assert n2 == 0 or n0 == 0
        if n2 == 0:
            print("0" * (n0 + 1))
            return
        if n0 == 0:
            print("1" * (n2 + 1))
            return
    # если и n0, и n2 равны 0, то вывести чередование 0/1 в количестве n1 + 1
    if n0 == 0 and n2 == 0:
        print(''.join([str(i % 2) for i in range(n1+1)]))
        return

    # если n0 или n2 равны 0, то можно представить себе как "1111010101"
    # то есть "стабильность... переходы"
    if n0 == 0:
        print("1" * (n2 + 1) + ''.join([str(i % 2) for i in range(n1)]))
        return
    if n2 == 0:
        print("0" * (n0 + 1) + ''.join([str((i + 1) % 2) for i in range(n1)]))
        return
    
    # если все значения ненулевые и n1 нечетное, то представим как 
    # 000000101010111111
    if n1 % 2 == 1:
        print("0" * (n0 + 1) + ''.join([str((i + 1) % 2) for i in range(n1)]) + "1" * n2)
        return
    
    # если все значения ненулевые и n1 четное, то надо представить так:
    # 110001010111
    # каких блоков больше ("11" или "00"), те и будут "снаружи", то есть лидирующими и замыкающими
    if n0 >= n2:
        print("001" + "1" * n2 + ''.join([str(i % 2) for i in range(n1 - 1)]) + "0" * (n0 - 1))
        return
    else:
        print("110" + "0" * n0 + ''.join([str((i + 1) % 2) for i in range(n1 - 1)]) + "1" * (n2 - 1))
        return


inp = int(input())
for _ in range(inp):
    n0, n1, n2 = tuple(map(int, input().split()))
    solution(n0, n1, n2)