## Видео с конференций

[**Станислав Рождественский "Грехи пользовательских историй", Analyst Days**](https://www.youtube.com/watch?v=S4yUgnmRa0Q)

Распространенные ошибки:
- безликость (не указано кто действующее лицо истории, "я как пользователь")
- неконкретность (хочу всё, чтобы делать всё)
- не указана мотивация (просто "я хочу", "я как покупатель хочу корзину покупок")
- мотивация не объясняет зачем, а описывает желание ("я как пользователю, хочу корзину покупок, чтобы смотреть, какие в ней товары")

[**Андрей Дятлов "Source Generator в действии", DotNext**](https://www.youtube.com/watch?v=6QWZds35rGs)

Если нужно большое количество специфичного boilerplate в коде, то можно использовать Source Generator на стороне Roslyn (но пока подобные сценарии не просматриваются)

[**Егор Богатов "Что нового в JIT-компиляторе", DotNext**](https://www.youtube.com/watch?v=Lkza7La1W4k)

Запуск приложения .NET 6 с флагами PGO может дать прирост в производительности 10-15% за счет увеличения времени "прогрева". [Подробности](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-6/#jit)

[**Владимир Перепелица "Как правильно выбрать очередь", HighLoad**](https://www.youtube.com/watch?v=hEC8CX8Drac)

Доклад начального уровня. Новая информация: упрощенные очереди (ZeroMQ), которые быстры, но могут терять сообщения; облачные решения (SQS) сейчас не актуальны.

[**Андрей Смирнов "Анатомия веб-сервиса", HighLoad**](https://www.youtube.com/watch?v=KAWeC9evbGM)

Теоретические основы многозадачности (процессы, потоки, кооперативная многозадачность), реализации кооперативной многозадачности (обратные вызовы, green-thread). Примеры подключение PostgreSQL - процесс, MySQL - поток операционной системы, Redis - кооперативная многозадачность, nginx - комбинированный вариант потоки ОС + кооперативные потоки. PgBouncer - прокси-балансировщик для расположения перед БД PostgreSQL для экономии соединений (pipelining).

**Алексей Коновкин "API-Gateway - как не допустить хаоса при цифровой трансформации на примере телеком-оператора", Highload 2022 [non-public](https://conf.ontico.ru/videos/4380349)**

Компания Nexign на основе nginx разработала собственный API шлюз. Основные нефункциональные требования: горизонтальное масштабирование, распределенное кеширование сессий, распределенное отказоустойчивое хранилище реестра конфигураций, переживать полную или частичную потерю связи с реестром. В качестве кеша используется Redis; в качестве хранилища реестра - ZooKeeper; для маршрутизации используется базовый nginx и Lua. Для реализации маршрутизации и балансировки есть два подхода: с единым портом (удобно, когда делаем новый API) или с возможностью разделения по портам. Конфигурация nginx статична, изменение списка портов можно сделать только при перезагрузке приложения. Реализации авторизации: Basic (логин/пароль), JWT-токен, [opaque-токен](https://cloudentity.com/developers/basics/tokens/opaque-token/) (формат OpenID не привязан к JWT), [Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow), Token Exchange. Трансформация запросов реализована за счет nginx и Lua-скриптов. Защита и квотирование: circuit breaker (переиспользован из nginx), throttling (использует две скользящих средних: отношение latency к количеству запросов), quoting (механизм определения политики квот и счетчики текущих условий).

**Юрий Печатнов "Exactly once передача данных без материализации", Highload 2022 [non-public](https://conf.ontico.ru/videos/4380313)**

Тривиальная схема потоковой обработки: данные -> решардеры (которые разделяют данные по ключу) -> промежуточные очереди -> агрегаторы (каждый отвечает за свою пачку включей) -> хранилище "ключ-значение". Минусы такой схемы: материализация промежуточной очереди. Если убрать промежуточную очередь, то теряется отказоустойчивость при отказах агрегаторов. Решение: промежуточная очередь используется только в случаях переполнения решардера, в иных случаях решардер работает напрямую с агрегатором. Для синхрозации прямого режима и промежуточной очереди используется идентификатор предыдущего сообщения.
