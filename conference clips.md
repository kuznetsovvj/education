
# Конспекты видео

## **Разработка на .NET**

### [**Андрей Дятлов "Source Generator в действии", DotNext**](https://www.youtube.com/watch?v=6QWZds35rGs)

Если нужно большое количество специфичного boilerplate в коде, то можно использовать Source Generator на стороне Roslyn (но пока подобные сценарии не просматриваются)

### [**Егор Богатов "Что нового в JIT-компиляторе", DotNext**](https://www.youtube.com/watch?v=Lkza7La1W4k)

Запуск приложения .NET 6 с флагами PGO может дать прирост в производительности 10-15% за счет увеличения времени "прогрева". [Подробности](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-6/#jit)

### [**Огородников, Просин, Хабаров "Аутентификация и авторизация на платформе .NET", DotNext**](https://www.youtube.com/watch?v=hFwIAPG6V4I)

- Базовая реализация - ASP.NET Core Identity.
- Negotiate (реализация через Kerberos, под капотом двойной обмен запросами с 401 кодом и крипто-посылками, не показываются в Network)
- OAuth 2.0. [RFC6749](https://datatracker.ietf.org/doc/html/rfc6749)
- Open ID Connect расширяет OAuth 2.0 в плане получения информации о пользователе.

### [**Евгений Пешков "Клиентский HTTP в .NET", DotNext**](https://www.youtube.com/watch?v=YvczsQP1SLM)

В .NET Core 2.1+ основным API является HttpClient с SocketHttpHandler (managed-реализация поверх сокетов, гарантируется одинаковое поведение на разных платформах - но поверх сокетов, сами win/unix/mac-сокеты могут иметь отличия). Обертки для сохранения совместимости (WebRequest, WebClient) не рекомендуется использовать (например, полностью копируют в память передаваемый Stream).

С осторожностью использовать кастомные клиенты из NuGet (RestSharp использует в реализации WebRequest, Swagger.Codegen использует для клиента RestSharp-клиент).

Протокол HTTP 1.1 (pipelining, keep-alive, Chunked Transfer Encoding - отправка сообщения неизвестной длины, стрим режется на части и длина каждой части сообщается перед передачей данных). HTTP 2.0 эффективнее использует TCP-соединение, но есть две реализации (h2c и шифрованная http-over-TLS) не полностью совместимые между собой. Можно указать версию протокола внутри HttpMessage, но следует всегда проверять (по умолчанию, если нет TLS, но все равно будет использоваться версия 1.1). GRPC работает поверх HTTP 2.0. HTTP 3.0 работает поверх протокола UDP, но фунцкиональность для .NET еще в разработке.

### [**Денис Тарасов, Дмитрий Афанасьев - Атакуем цепочку поставок, DotNext**](https://www.youtube.com/watch?v=v2C_Nu-y_TQ)

Основные проблемы и возможные уязвимости:

- файл packages.config может включать в себя powershell-скрипты, которые будут исполняться при установке и удалении приложения
- вредоносный powershell-скрипт можно внедрить в файл .targets nuget-пакета. При сборке с правами администратора (в IDE или CI/CD билдере код выполнится)
- атака на приватные пакеты (если разместить аналогичный код в публичном репозитории, например nuget.org)

Рекомендации:

- использовать директиву \</clear> в nuget конфиге
- использовать флаги --deprecated и --vulnereable при сборке приложения
- резервиварования общего префикса для приватных пакетов в nuget.org [инструкция](https://learn.microsoft.com/en-us/nuget/nuget-org/id-prefix-reservation)
- блокировка прямого доступа к nuget.org (или полный отказ от него)

## **Фреймворки и инструменты**

### [**Владимир Перепелица "Как правильно выбрать очередь", HighLoad**](https://www.youtube.com/watch?v=hEC8CX8Drac)

Доклад начального уровня. Новая информация: упрощенные очереди (ZeroMQ), которые быстры, но могут терять сообщения; облачные решения (SQS) сейчас не актуальны.

### [**Андрей Смирнов "Анатомия веб-сервиса", HighLoad**](https://www.youtube.com/watch?v=KAWeC9evbGM)

Теоретические основы многозадачности (процессы, потоки, кооперативная многозадачность), реализации кооперативной многозадачности (обратные вызовы, green-thread). Примеры подключение PostgreSQL - процесс, MySQL - поток операционной системы, Redis - кооперативная многозадачность, nginx - комбинированный вариант потоки ОС + кооперативные потоки. PgBouncer - прокси-балансировщик для расположения перед БД PostgreSQL для экономии соединений (pipelining).

### **Олег Бартунов, Иван Панченко "Postgres от начала веков и до наших дней", Highload Saint 2022 offline**

- *Рекомендация: Статья Эдгара Кодда про реляционную модель* [pdf](https://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf)
- *Рекомендация: Книга Егора Рогова "Про внутренногости PostgreSQL"* [купить](https://dmkpress.com/catalog/computer/databases/978-5-93700-122-2/)

### **Дарья Петрова "Цифровизация бизнесов на базе Jira", Highload Saint 2022 offline**

- Процессы важнее инструментов, но если инструмент неудобен им пользоваться не будут
- Управление проекта внедрения делали в ToDoist, Trello, главный минус: нельзя переиспользовать наработки старого проекта в новом, без ретро-анализа
- Для построения процесса в Jira нужен отдельный ресурс (люди, команда), инструмент Jira Structure
- Потребность в нормальном управлении процессом есть у всех, но не все осознают, что Jira и борды помогут
- Большой плюс единства интерфейса (рабочие задачи и обслуживающие процессы: заказ пропусков, тех.саппорт, отпуска)
- CRM дороги, а Jira уже куплена (пример на 300 человек, разработка расширения Jira - 650 тыс, использование ZohoCRM - 100 тысяч в месяц)

### **Алексей Плетнёв "Свой распределенный S3 на Minio: практический опыт по наступанию на грабли", Highload Saint 2022 offline**

- Выбор хранилища: AWS, GCP - не устраивают по latency; Yandex, VK - по цене; ceph, OpenIO - сложно
- MinIO не гарантирует, что все резервные копии окажутся на разных нодах
- Нельзя избежать downtime при обновлении/расширении кластера (все ноды обновляются разом)
- *TODO: Узнать подробнее про ZFC пулы*

### [**Андрей Парамонов "gRPC: Наш опыт внедрения", DotNext Spring 2022**](https://www.youtube.com/watch?v=y5nLqQPSPBI)

Обзорный доклад по gRPC, много подробностей про HTTP/2. Упрощенные аналоги RPC: Apache Thrift, Twitch Twirp. Резкий рост производительности gRPC в .NET 6 и 7.

### [**Сергей Васильев - Обработка XML-файлов как причина появления уязвимостей, DotNext**](https://www.youtube.com/watch?v=7L21g7eedtA)

XEE (XML Entity Expansion) - механизм определения ENTITY в XML через другие ENTITY (рекурсивная схема). Для предотвращения угрозы, необходимо обязательно устанавливать лимиты на размер XML-файлов.

XXE (XML eXternal Entity) (подвид атаки SSRF - Service-Side Request Forgery) через подмену внешних Entity. Необходимо использовать только безопасные XmlResolver (XmlUrlResolver небезопасный).

Важные настройки парсера: DTD processing (не обрабатывать сущности), EE resolving (не обрабатывать внешние сущности), Weak restrictions (ограничение по объему файлов).

Парсеры по умолчанию опасны <= .NET Framework 4.5.1, более современные версии по умолчанию безопасны. Для проверки можно использовать SAST (статичный анализатор, Static Application Security Testing) и SCA (Security Composition Analysis, анализ компонентов приложений по доступным базам).

### [**Станислав Флусов - Миграция с MS SQL на PostgreSQL, DotNext**](https://www.youtube.com/watch?v=3DcCX89Mz78)

Enterprise-решения движков баз данных могут быть в 5-10 раз дороже, чем сервер, на который они установлены. PgWatch - готовое решение для мониторинга PostgreSQL, которое разворачивается из docker.

Postgre по умолчанию чувствителен к регистру при поиске по строкам (MS SQL не чувствителен). В качестве решения задавать Collaction для конкретных столбцов (но не будет работать на функции LIKE, необходимо использовать ILIKE), или использовать нормализованные столбцы. Нет ключевого слова TOP (используй LIMIT, или синтаксис SQL2016 - OFFSET 30 FETCH NEXT 10 ROWS ONLY).

В Postgre отсутствуют TABLE HINTS (так как Postgre использует cose-based оптимизатор запросов).

Инструменты для миграции: Babelfish (плагин для PostgreSQL, который позволяет работать с ней через T-SQL), AWS SCT (Schema Conversion Tools) генерирует скрипты для миграции из платных баз данных в open source (работает не только на схемы, но и на скрипты запросов).

Самый простой способ переноса данных между базами - через csv файлы (10-100 Гб базы). В PG есть инструмент аналогичный LinkedServer (TDS Foreign Data wrapper) или PGLoader (pfloader.io).

### [**Павел Лакосников - SLI/SLA/SLO в микросервисном приложении, HighLoad**](https://www.youtube.com/watch?v=h0aZ_QNMTxU)

SLO (Service Layer Objective) - декларируемый уровень качества приложения (например, время ответа на 95% перцентиле, количество ошибок 500 за промежуток времени, время обработки критической инцидента). Service Layer Indicator - фактическое состояние заявленных метрик. Service Layer Agreement - что мы делаем, если SLI хуже, чем SLO. Например, Amazon, если доступность 99-99.95 - скидка 10%, если 95-99 - скидка 30%, если меньше 95 - возврат 100%.

Бюджет ошибок - оставшийся процент времени/запросов, при котором SLO не выполняется. Что считать ошибкой? Те запросы/временные периоды, в которых не выполняются NFR (Non-Function Requirements). Траты бюджеты стоит разбивать на категории по типам ошибок. Если бюджет ошибок превышен, то рассматриваем SLA (пересматриваем NFR, закладываем технические работы, временный мораторий на релизы).

Как подсчитать метрику надежности приложения?

- Сумма всех ошибок (легко считать, легко понять; не учитывает важность вклада каждой страницы/сервиса, "температура по больнице")
- Ошибки по платежам (легко считать, легко понять; не считает косвенные потери, не эластична, не реактивна, "важная часть системы - не вся система")
- Воронка продаж (надежность каждого этапа и конверсия, не весь траффик целевой)
- Воронка продаж с потерянными ошибками (отказ на верхнем уровне воронки даст "недополученные ошибки" на нижних с учетом конверсии)
- Подсчет ошибок в зависимости от точки входа (легко считать, понятна бизнесу, покрывает лишь один аспект работы, требуется пересчитывать коэффициенты)

## **Архитектура приложений**

### [**Алексей Коновкин "API-Gateway - как не допустить хаоса при цифровой трансформации на примере телеком-оператора", Highload 2022**](https://www.youtube.com/watch?v=T-JnDK6KyxI&list=PLH-XmS0lSi_zCq4H_OZrXD509X23xwvao&index=97)

Компания Nexign на основе nginx разработала собственный API шлюз. Основные нефункциональные требования: горизонтальное масштабирование, распределенное кеширование сессий, распределенное отказоустойчивое хранилище реестра конфигураций, переживать полную или частичную потерю связи с реестром. В качестве кеша используется Redis; в качестве хранилища реестра - ZooKeeper; для маршрутизации используется базовый nginx и Lua. Для реализации маршрутизации и балансировки есть два подхода: с единым портом (удобно, когда делаем новый API) или с возможностью разделения по портам. Конфигурация nginx статична, изменение списка портов можно сделать только при перезагрузке приложения. Реализации авторизации: Basic (логин/пароль), JWT-токен, [opaque-токен](https://cloudentity.com/developers/basics/tokens/opaque-token/) (формат OpenID не привязан к JWT), [Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow), Token Exchange. Трансформация запросов реализована за счет nginx и Lua-скриптов. Защита и квотирование: circuit breaker (переиспользован из nginx), throttling (использует две скользящих средних: отношение latency к количеству запросов), quoting (механизм определения политики квот и счетчики текущих условий).

### [**Юрий Печатнов "Exactly once передача данных без материализации", Highload 2022**](https://www.youtube.com/watch?v=nc0FfVwmjBU&list=PLH-XmS0lSi_zCq4H_OZrXD509X23xwvao&index=14)

Тривиальная схема потоковой обработки: данные -> решардеры (которые разделяют данные по ключу) -> промежуточные очереди -> агрегаторы (каждый отвечает за свою пачку включей) -> хранилище "ключ-значение". Минусы такой схемы: материализация промежуточной очереди. Если убрать промежуточную очередь, то теряется отказоустойчивость при отказах агрегаторов. Решение: промежуточная очередь используется только в случаях переполнения решардера, в иных случаях решардер работает напрямую с агрегатором. Для синхрозации прямого режима и промежуточной очереди используется идентификатор предыдущего сообщения.

### **Александр Тоболь "Архитектура: история и будущее на примере Вконтакте", Highload Saint 2022 offline**

- Позиция архитектора не нужна (невозможно принимать решения о развитии системы в одиночку, только коллегиально)
- Разница в понятиях "архитектура" и "структура" (design): архитектура определяет воспроизводство структуры
- ["Гипотеза об устойчивости структуры" Мартина Фаулера](https://martinfowler.com/bliki/DesignStaminaHypothesis.html)
- [Закон Амдала о параллельных вычислениях](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%BA%D0%BE%D0%BD_%D0%90%D0%BC%D0%B4%D0%B0%D0%BB%D0%B0)
- Подход Engine VK - фактически это микросервис на С/С++ с embedded database
- VK использует свой бинарный протокол сериализации Type Language (по типу Protobuf)
- RPS взаимодействие переведено на TypeLanguage/RPC_UDP для экономии памяти буферов
- Причина ввода умной ленты? Большинство пользователей не успевали просмотреть свою календарную ленту (не все прошаренно постоянно удаляли всякий мусор из ленты)
- Раскладка горячего контента на 50 CDN, Geo-DNS работал плохо из-за постоянно меняющихся/падающих сервисов
- Если остановить сервер с uptime > 10 лет, то велика вероятность, что RAID умрет целиком
- *TODO: Протокол QUIC и оптимизации сжатия*
- *TODO: Поподробнее про NUMA*
- *TODO: Составить чек-лист для разработчика, когда задача уже готова*

### **Евгений Пак "Без А/В результат ХЗ", Highload Saint 2022 offline**

- *Рекомендация: Рой Кахави "Доверительное А/В-тестирование"* [купить](https://www.ozon.ru/product/doveritelnoe-a-v-testirovanie-224221240)
- Платформа для A/B-тестирования состоит из быстрого разделителя пользователей (500k RPS) и медленной асинхронной системой сбора статистики
- *TODO: etcd - key-value storage с функцией уведомления об изменениях*
- Будь осторожен, складывая важные бизнес данные в headers, ограничения в 4 Кб, используй кастомные кодирования/сериализации

### **Михаил Кабищев "Одна платформа, чтобы править всеми", Highload Saint 2022 offline**

- Платформа нужна для снижения time-to-market (стандартизация, унификация инфраструктуры кода, решение типовых задач), платформа - технологический фундамент
- Конвенция по микросервисам (миниконституция): именование, версионирование, конфигурирование, протоколы, observability
- Конвенции по языкам/технологиям: версии языков, библиотек, code style, лучшие практики
- Создание сервисов через генераторы/шаблоны
- Конфигурирование и утилита доставки
- Где и как хранить контракты? Кто и как их генерирует? Для Go и gRPC утилиты Protogen (2020) и Mimir (2022) - обе пока не в open-source
- Managed Services (автоматическое разворачивание БД, Redis, Memcached)

### **Филипп Дельгадо "Микросервисы через боль и превозмогание", Highload Saint 2022 offline**

- Минусы микросервисов: сложная аналитика, целостность, надежность, сложность
- Плюсы микросервисов: разнообразие подходов, людей, фреймворков; изоляция проблем и неопределенности; упрощение архитектурного надзора, маркетинг (модно!)
- *TODO: Что такое PCI DSS? Что-то связанное с карточными операциями*
- Теоретия систем - как разделить систему на подсистемы (вспомни уроки Системной инженерии)
- *Рекомендация: книги Ричарда Фейнмана*
- *Рекомендации: изучить ТФКП - Теорию функций комплексной переменной*
- Service-Mesh как решение сложной процедуры деплоя/канареечных релизов
- Канареечные релизы над очередями (в частности kafka) - всегда очень плохие решения
- Длинная транзакция (сага) в микросервисах порождает вопросы: Как понять, что возникла проблема? Кто должен это понять? Кто и как запускает компенсацию?
- Варианты саг: оркестрация с регистратором, хореография с регистратором (регистратор - god-like object), хореография без регистратора (весь контект операции прикрепляется к сообщению), оркестрация без регистрации
- Проблемы саг: не всегда есть компенсация, компенсировать все проблемы подряд - дорого, компенсация нужна для всего сценария, а не для шага
- Решение: не сага, а work-flow. Нет компенсации шага, но есть "негативный сценарий №Х"
- Инструменты для Work-flow: Cadence, Temporal, Camunda

### [**Евгений Хренов "Архитектура приложений в банке (raiffeisen)", учебный курс Slurm**](https://www.youtube.com/watch?v=RM7D5-hpgJY)

Сложности со сквозными процессами через многие продукты решаются с помощью отдела архитектуры; проблема взаимных блокировок команд с помощью Open Source и общим владением кодом. Продуктовые команды "зажаты" между цифровым каналом (мобильным приложением, сайтом, публичным API, колл-центром) и платформой разработки.

Способы декомпозиции микросервисов: по бизнес-возможностям, monolith-first, design-driven development.

Хорошая идея: словарь для общих терминов (на русском на разговоре и на английском для кода); имена внешних систем; имена бизнес-артефактов (тип документов); имена подразделений и команд.

### [**Александр Кривощёков "Паттерны отказоустойчивой архитектуры", HighLoad**](https://www.youtube.com/watch?v=WWTq-tbZwUE&list=PLH-XmS0lSi_zCq4H_OZrXD509X23xwvao&index=6)

- Retry. Полезен при временном отсутствии сети, ограничениях. Ограничивается или количеством повторов, или временем. Главная проблема в реализации: дублирование бизнес-процессов, решается с помощью ключей идемпотентности. Приложение повторяет запросы если они идемпотентны (get, trace, head, options), или имеют хедер идемпотентности;
- Deadline - timeout на клиентской стороне (намного лучше чем cancellationToken в Http-клиенте). Серверу тоже полезно знать, сколько клиент будет ждать выполнения запроса (может его и не стоит выполнять?)
- Rate-limiting. Важно отдавать честный статус 429 Too Many Response, следует использовать смешанные подходы (burst-, rate- с fixed/sliding-window).
- Circuit-breaker. "Рубильник", который выключает приложение, если что-то сломалось. Автовосстановление по timeout/на малой части траффика/health check.
- Rich client. Перенос части вычислений со стороны сервера на сторону клиента (особенно полезно при недоступности сервиса)
- Dummy/Pumpkin. Фактически, bypass. Упрощенная минимальная версия приложения без зависимостей (например, заявки пишутся в лог). Спасает при полной смерти основного приложения.

Другие важные паттерны: health checking, exponental back-off и jitter, caching/failover caching, failover, "прямые руки!".

### [**Александр Тоболь "VK Видео: архитектура крупнейшей видеоплатформы", HighLoad**](https://www.youtube.com/watch?v=8ICxQ-UPVn0&list=PLH-XmS0lSi_zCq4H_OZrXD509X23xwvao&index=3)

Стандартная архитектура контент-платформы: upload, transform, storage, stream. Важное замечания: обязательно хешировать входящий контент (когда клиенты пришлют битый контент, важно, чтобы все трансформемры не были убиты им).

### [**Артем Рудневский "Exactly-once в микросервисной среде", DotNext**](https://www.youtube.com/watch?v=SKR1FK6qkZk)

Паттерн Transaction Outbox - повторная проверка при отправке в Kafka для строгой exactle-once (но очень замедляет работу). Аналог: transaction log tailing - прямое чтение transaction log СУБД (но дает жесткий coupling с БД).

Не забыть добавлять случайную составляющую к времени следующей попытке при повторе, чтобы сглаживать пики при проблемах на сервисе. Не забыть, что Redis очень дорог.

### [**Александр Поломодов - Как подготовиться и пройти System Design интервью, ArchDays**](https://www.youtube.com/watch?v=jUbOm0B-eKQ)

1. Формализация задачи:
    - задавать вопросы о scope
    - функциональные требования = сценарии использования (Use Cases, User Story, Jobs to be Done)
    - нефунцкиональные требования (выделить самые важные)
    - определить приоритет (иерархию) требований по важности (Architecture Tradeoff Analysis Method)

1. Границы системы:
    - выбрать правильный метод интеграции (файлы, db, api, messaging)
    - выбрать подход к API (REST, RPS, GraphQL) - System Context C4 Diagram
    - описать контракты в выбранном подходе (Таненбаум "Компьютерные сети", Хофф "Enteprise Integration Pattern")
    - балансировщики нагрузки (nginx, HaProxy)
    - API Gateway

1. Основные компоненты и потоки данных
    - happy-path (основной поток работы)
    - exception flow (уточнить, нужно ли прорабатывать?)
    - read/write-path (schema on read, schema on write)

1. Концептуальная схема
    - рабочие нагрузки stateful/stateless
    - проектирование модели данных
    - выбирать места для stateful-компонентов (RDMS, NoSQL - key-value, document-oriented, column-oriented, graph). См. "K8s Patterns", "12-факторные приложения".

1. Реальная схема и архитектурные характеристики
    - выбрать конкретные реализации
    - думать о концепции failure
    - проектировать с учетом operations (логи, мониторинг, миграции) - "Building Secure & Raliable Systems"

1. Масштабирование под нагрузку
    - stateless (оркестраторы, k8s)
    - stateful (партиционирование, шардинг)

## **Управление разработкой**

### [**Александр Поломодов "Канал. Продукт. Платформа или Эволюция подходов к развитию мобильного банка Тинькофф", HighLoad**](https://conf.ontico.ru/videos/4536831)

Мобильный банк Тинькофф - 80 команд и 400 разработчиков. До внедрения release train - релизы раз в квартал, регресс 15 дней. Для борьбы с регрессом сделали обязательным автотестирование всех новых фич. Разделение команды на core-team (платформенную) и бизнесовые (продуктовые). Продуктовые команды становятся сквозными (мобильное приложение, API, backend).

Рекомендация: книга Team Topologies, [блог Александра Поломодова на medium](https://apolomodov.medium.com/), изучить что такое Architecture Fitness-function.

Триггеры, что команде требуются изменения:

- софт стал слишком большим для одной команды;
- темпы поставки устойчиво снижаются;
- бизнес-сервисы опираются на разрозненный набор различных сервисов.

## **Аналитика**

### [**Станислав Рождественский "Грехи пользовательских историй", Analyst Days**](https://www.youtube.com/watch?v=S4yUgnmRa0Q)

Распространенные ошибки:

- безликость (не указано кто действующее лицо истории, "я как пользователь")
- неконкретность (хочу всё, чтобы делать всё)
- не указана мотивация (просто "я хочу", "я как покупатель хочу корзину покупок")
- мотивация не объясняет зачем, а описывает желание ("я как пользователю, хочу корзину покупок, чтобы смотреть, какие в ней товары")

## **Управление командой**

### [**Андрей Минкин "Путь в тимлиды и обратно", TeamLead Saint 2022**](https://www.youtube.com/watch?v=r22K8mU5_pA&t=3025s)

- *Рекомендация: Джоко Виллинг "Дисциплина - это свобода"*
- *Рекомендация: инструмент ["управленческое слабоумие"](https://habr.com/ru/company/oleg-bunin/blog/552116/)*
- Путь к CTO: как не растерять технические навыки? Ревью кода, архитектурные митинги и решения, исследование архитектур и дизайна систем, codewars, помочь кому-нибудь решить задачу, участие в сборе требований
- Запланировать со всеми 1-на-1 - регулярные встречи раз в месяц
- *TODO: что такое SWOT в Risk management?*

### [**Виталий Леонов "Приборная панель тимлида. Как оцифровать все и спать спокойно", TeamLead Saint 2022**](https://youtu.be/r22K8mU5_pA?t=7121)

Тимлиду следует контролировать три сферы: техническое качество ПО, процессы разработки и команду. Наиболее полезные показатели качества ПО: стоимость инфраструктуры на пользователя (запрос), количество запросов в секунду, среднее время ответа, утилизацию ресурсов (CPU, RAM), количество ошибок в секунду. Метрики процесса разработки (почти все взяты из Скрама): burndown chart, velocity, bug cycle time (время жизни бага от обнаружения до устранения), четыре ключевых метрики (см. TechRadar: среднее время жизни задачи, частота релизов, среднее время восстановления, процент релизов с ошибками). Метрики команды наиболее сложные для измерения, для примера: воронка найма, скорость найма по длительности этапов, скорость онбоардинга (время до N-го MR), текучесть. В докладе описано много-много метрик, но нет практических советов как их собирать.

### [**Олег Балбеков "Забота компании о сотрудниках - это измеримый показатель", TeamLead Saint 2022**](https://www.youtube.com/watch?v=r22K8mU5_pA&t=17455s)

Забота - любые действия компании, которые приносят пользу сотруднику (подарки, рост заработной платы, обучение за счет компании). Компания Evrone оценивает заботу по трем категориям: польза для работника, стоимость для компании, эмоции для работника. Категории заботы:

- Знания (участия в митапах, менторство, обучение за счет компании, участие в конфенерциях)
- Развлечения (мерч, подарки, онлайн и оффлайн вечеринки, большой корпоратив)
- Компенсация и рост (увеличение грейда, увеличение зарплаты, внеплановая премия)
- Поддержка (1v1, смена проекта по желанию сотрудника)

### [**Алексей Обровец "Питательная среда для качественной внутренней коммуникации", TeamLead Saint 2022**](https://www.youtube.com/watch?v=DxgFO9E1Hn8&list=PL_L_HiHe5k_2sEh1wpJUQoEoTDjqralLV&index=4)

Важно установить правила общения в команде/компании. Например: "нет данных для подтверждения гипотезы - на совещании молчу", "вдох - улыбка - инвестиции" (Давай решим, как мы это исправим), "упражнение конфета" (посмотри, что там внутри).

## **Публичные выступления**

### [**Женя Голева. Серия видео "Клуб спикеров"**](https://www.youtube.com/playlist?list=PL8k3JUjfjpzgM-RjA7jTvk-QJMC6tzhzz) via [telegram](https://t.me/speakersclub)

Хорошее выступление имеет структуру: Я ...; Тема ...; Кому и зачем? (тезисы в программе конференции никто не читает!); План: (особенно важно для длинных выступлений); Техническая часть ("мясо"); Call to action (что я хочу, чтобы люди сделали).

Проблему надо формулировать четко: те факты, которые могут быть очевидны для докладчика, могут быть совершенно непонятны и неясны слушателям.

Каждый слайд содержит достаточно точек для привличения внимания аудитории. Если блок-схема большая, лучше сделать последовательное появление блоков (слайд за слайдом). Сложные графики: один график на один слайд, убирать легенды. На чтение графика люди тратят много времени.

Завершать доклад лучше словами "На этом я заканчиваю свой доклад и готов ответить на ваши вопросы. Напоминаю, меня зовут Владимир Кузнецов...". Отвечай на вопрос всем, не только тому, что спрашивал. Не увлейкайся дискуссией (не трать время всех остальных).

## **Неклассифицируемое**

### **Дмитрий Завалишин "Языки программирования: прошлое, настоящее, будущее", Highload Saint 2022 offline**

- Конкуренция в мире - прежде всего конкуренция моделей управления
- Важнейший показатель IT-решения: Total Cost Of Ownership (полная стоимость владения)
- Во вреня оценки TCO затраты на начальную разработку составлять единицы процентов (<5%)
- Общая стоимость: разработка + поддержка в год * срок жизни + стоимость железа
- Почему живы "прожорливые" языки типа Python, PHP? Не всем нужны продуктовые кластеры из десятков ядер
- Стоимость разработки оптимальна в маленьких проектах на python, в больших - Java/.NET
- "В прикладной разработке программировать на С - грешно, на С++ - грешновато" (Завалишин)
- За JIT-компиляцией, использующей статистику всей среды исполнения будущее (см.доклад Богатова про PGO)
- *Рекомендация: Книга "Оптимизация С-кода под Эльбрус"* [pdf](http://www.mcst.ru/files/5ed39a/dd0cd8/50506b/000000/elbrus_prog_2020-05-30.pdf)
- *TODO: Как работает PhantomOS?*

### [**Максим Лапшин "История on-line видео", HighLoad Saint 2022**](https://conf.ontico.ru/videos/4536776)

Тенденции в онлайн видео:

- переход от централизованного вещания/программы на индивидуально подобранный контент
- переход на технологии, которые могут работать в браузере
- UDP приходит на замену TCP (потому что, TCP вносит непредсказуемые по времени задержки и HTTP/2 внедрялся так долго, что ему на смену пришел HTTP/3)
