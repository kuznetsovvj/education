# Набор видеоуроков от Марка Ричардса

## [Software Architecture Monday](https://www.developertoarchitect.com/lessons/)

### 1\. [**Request/Reply Pattern**](https://www.youtube.com/watch?v=3bxAm3XIFmk)

Для имитации request/reply используем две разных очереди сообщений. Сообщения можно связывать по CorrelationId (Id моего сообщения превращается в CorrelationId ответа) или через временные очереди (очереди только для одного сообщения, вероятно, будет огромный overhead на создание/удаление очередей).

### 2\. [**Kafka vs Message Broker**](https://www.youtube.com/watch?v=lwMjjTT1Q-Q)

Kafka оптимизирована под постоянный поток простых сообщений key/value, с нагрузкой до 1M/s и только под паттерн Publisher/Subscriber. RabbitMQ удобнее для транзакционных сообщений (в том числе большого размера), нагрузка до 10K/s с поддержкой трех разных паттернов (point-2-point, publisher-subscriber и exchange/routing - распределение сообщения по разным очередям)

### 3\. [**Soft skills: Gaining Technical Breadth**](https://www.youtube.com/watch?v=vRplv975ce0)

Для архитектора важна не только глубина знаний ("знаю, что знаю"), но и ширина знаний ("знаю, что знаю + знаю, что не знаю"). Чтобы повышать ширину знаний, нужно больше читать о новых событиях в мире, например, InfoQueue, Technical Radar или DZone.

### 4\. [**Microservices: Distributed Logging**](https://www.youtube.com/watch?v=S511BgBs_3E)

Микросервисы отличаются сложностью отладки, поэтому нужны хорошие логи. Выбрать инструмент для сбора логов (splunk, logstash, kafka и другие) - половина дела. Полезные приёмы:

- "консолидация логов" - объединение логов от разных микросервисов в один лог
- "идентификатор контекста запроса"
- "иерархия идентификаторов" (если есть userId - используем его, если нет, то requestId, если нет, то applicationId и т.д.), отличное место для извлечения id context - api gateway
- консистентность контекста - принимать его как входной параметр по всех запросах
- собственный wrapper для логов - это хорошо

### 5\. [**Microservices: Reducing Staging Iterations**](https://www.youtube.com/watch?v=dkLriZLXpU8)

При разделении монолита на микросервисы, по возможности, изменение архитектуры стоит вести параллельно с разворачиванием инфраструктуры и CI/CD процессов (силами devops)

### 6\. [**Classifying Architecture Patterns**](https://www.youtube.com/watch?v=Ic6q7S48Mho)

- монолитные архитектуры (microkernel, layered, pipeline, modular monolith)
- распределенные архитектуры (microservices, space-based, event-driven, service-based): создание контракта, поддержка, версионирование и координация контракта; проблемы с доступностью сервисов, медленнее вызовы удаленных процедур и протоколов, чем локальные; аутентификация и авторизация удаленных вызовов; распределенное логирование; атомарные транзакции и область видимости транзакции

### 7\. [**Analyzing Architecture: Structural Decay**](https://www.youtube.com/watch?v=gHLqroFX2Eg)

Процесс анализа архитектуры - это изучение текущего состояния архитектуры проекта и подготовка советов, которые позволят его улучшить. Структурный распад - нарушение архитектурных принципов, которые были использованы при разработке архитектуры проекта

### 8\. [**Analyzing Architecture: Components**](https://www.youtube.com/watch?v=jrohK2unyE8)

Во время анализа архитектуры важно разделить систему на компоненты. Компонентами могут быть подсистемы, слои, сервисы, обработчики событий, то из чего состоит приложение. В микросервисной архитектуры, как правило, компонентом является сам микросервис. Архитектура рассматривает взаимодействие между компонентами, а не их внутреннее устройство.

### 9\. [**Analyzing Architecture: Macro Techniques**](https://www.youtube.com/watch?v=h1So8tVukS8)

Индикаторы структурного распада на макро-уровне (всей системы):

- статичное связывание (static coupling)
- временное связывание (temporal coupling)
- размер компонентов (component size)

### 10\. [**Analyzing Architecture: Microservices**](https://www.youtube.com/watch?v=U7s7Hb6GZCU)

Индикаторы структурного распада на уровне микросервисов:

- большое количество межсервисных взаимодействий
- большое количество оркестрирующих запросов (один входящий и много исходящих)
- большое количество агрегирующих запросов (для ответа на входящий запрос, нужно сагрегировать информацию с многих других сервисов)
- связывание баз данных (разделение баз данных между разными микросервисами)

### 11\. [**Analyzing Architecture: Code Metrics**](https://www.youtube.com/watch?v=pELKNy8B5Nw)

Значение метрик не столь важно, сколько тенденция их изменения. Важнейшие метрики по Ричардсону:

- количество классов в сборке (в среднем)
- количество строк кода
- средняя сложность (1 + количество путей, чтобы пройти метод, целевое значение 2-4)
- глубина дерева наследования
- цикломатическая сложность (V = e - n + 2, e - edges - количество переходов между операторами, n - nodes - количество операторов)
- количество афферентных связей (центростремительных, внутренних)
- количестве эфферентных связей (выносящих, внешних)

### 12\. [**CQRS and Microservices**](https://www.youtube.com/watch?v=pUGvXUBfvEE)

Command Query Responsibility Segregation - паттер проектирования, который предполагает разделение команд, меняющих состояние в базе данных, и запросов, которые получают данные из базы. Операции базы данных на чтение и запись требуют разных оптимизаций, поэтому разделение базы на две части - "базы на чтение" и "базы на запись" (первая база синхронизируется со второй) даст выигрыш в скорости. Дальнейшая оптимизация: разделение исходного сервиса на два: микросервис на чтение будет работать с высокопроизводительным кешем в оперативной памяти (memcache, redis), микросервис на запись - обновлять данные в базе данных ("холодное хранилище") и горячем кеше читающего сервиса.

### 13\. [**Microservices and Reporting**](https://www.youtube.com/watch?v=n_7PCFkxPPw)

Схемы для организации сводных отчетов:

- database pull model - сервиса отчетов забирает данные из БД продуктовых сервисов (нарушение bounded context)
- http pull model - сервис отчетов забирает данные из API продуктовых сервисов (проблемы с производительностью, объемом данных)
- event-based push model - публикация событий на стороне продуктовых сервисов, обработка и агрегация событий в БД сервиса отчетов

### 14\. [**Refactoring Patterns: Migration vs. Adaptaion**](https://www.youtube.com/watch?v=DKPn0AcvLKo)

Миграция - замена некоторого компонента с заданным функционалом на новый. При миграции легко откатить изменения, снижается общий риск, но требует переключения логики запросов при смене компонентов. Адаптация - расширение функциональности уже имеющегося компонента ("на месте", без разворачивания нового сервиса). Адаптация сложнее в откате изменений, вызываемые компоненты не меняются. Выбор между миграцией и адаптацией определяется риском, стоимостью и связаностью системы.

### 15\. [**Refactoing: Business Justification**](https://www.youtube.com/watch?v=z2QjN6KKOQQ)

При объяснении бизнесу "Зачем нам нужен рефакторинг?" не стоит использовать технические термины как всё станет здорово, следует четко объяснить, почему бизнесу нужно за это заплатить. Основных мотивации для бизнеса три: снижение расходов, снижение time-to-market, удовлетворенность пользователей.

Пустые обещания ничего не стоят, обязательно нужно показывать измеримые метрики. Снижение расходов - количество багов, время на разработку и тетисрование; время поставки - часы разработки и время от идеи до поставки в продуктовую среду; удовлетворенность пользователей - количество багов, количество баг-репортов от пользователей, метрики производительности и скорости. Не стоит использовать опросы пользователей, они очень субъективны и предвзяты.

### 16\. [**The Challenge of Architecture Teams**](https://www.youtube.com/watch?v=RefvolwEOIc)

В командах архитекторов не может быть общего мнения, конфликты являются нормой. Целью работы команды архитекторов является выработка общего мнения, основанного на знаниях всей команды. В качестве решения можно использовать выбор медиатора; который после тщательного обсуждения мотивированных предложений, сделает решение. Тогда, все оставшиеся члены команды должны согласится с принятым решением.

### 17\. [**Architecture Tradeoffs**](https://www.youtube.com/watch?v=52haYbu80e8)

Архитектурные компромиссы: производительность, масштабируемость, расширяемость, гибкость, ремонтопригодность (maintainability) и осуществимость (feasability) - по бюджету и срокам. ATAM (Architectury Tradeoffs Analysis Method) - способ анализа предлагаемых архитектур на соответствие бизнес-задачам и атрибутам качества. Минусы процесса: предлагаемая архитектура должна быть готова, stakeholders очень заняты и часто распределены, предполагает однократный процесс, без эволюции, предполагает, что все бизнес-требования известны.

Этапы процессе:

- создать презентацию архитектуры
- валидация архитектуры и определение компромиссов
- идентификация и разрешение рисков
- утвереждение у stakeholders.

CBAM (cost-benefit analysis method) основан на максимизации разницы между преимуществами и стоимостью. [ATAM Technical Report](https://resources.sei.cmu.edu/library/asset-view.cfm?assetId=5177)

### 18\. [**Fallacies of Distributed Computing**](https://www.youtube.com/watch?v=UZxLYv5RFyI)

Заблуждения, касающиеся распределенных систем:

- сеть надежна
- задержка равна нулю (это не локальный вызов в памяти!)
- пропускная возможность каналов бесконечна
- сеть безопасна
- топология сети не меняется
- есть только один администратор
- транспортные затраты равны нулю (завтраты на сетевое оборудование)
- сети гомогенные

### 19\. [**Intergration Styles: File Transfer**](https://www.youtube.com/watch?v=_uRYlUuxjVA)

В книге "Enterprise Integration Patterns" (Hohpe, Wolf, 2003) определяется четыре стиля интеграции: передача файлов, общая база данных, удаленный вызов процедур и сообщения. Основные протоколы передачи для файлов - FTP/SFTP, HDFS (Hadoop), SCP (Secure Copy Protocol), SMB (Server Message Block), CIFS (Common Internet File System). Преимущества: универсальный, простая интеграция, полная абстракция систем. Минусы: обработка ошибок очень сложна, медленная синхронизация данных (как узнать, что данные уже пора читать? только по расписанию?), передача исключительно только данных.

### 20\. [**Integration Styles: Shared Databases**](https://www.youtube.com/watch?v=CSAFJNoT34M)

Приложения ничего не знают друг о друге, но используют одну базу данных. Преимущества: универсальная интеграция (почти все системы доступны через SQL/ODBC), абстрация систем, независимость систем ("decoupling"), простота интеграции. Недостатки: плохо работает с ORM (ORM построены по принципу эксклюзивного владельца БД; много промахов кеша на стороне ORM), сложности с "бутылочными горлышками" производительности, сложности с изменениями схемы; данными не владеет никто.

### 21\. [**Integration Styles: Remote Procedure Invocation**](https://www.youtube.com/watch?v=OGgbajZNwpU)

Приложение удалённо вызывает процедуру другого приложения и получает ответ. Используемые протоколы: REST (Representational State Transfer), SOAP (Simple Object Access Protocol), RMI (Remote Method Invocation), CORBA (Common Object Request Broker Architecture), WebSockets, gRPC. Преимущества: инкапсуляция данных и четкий владелец данных, внешняя интеграция систем (интеграция за файрволлами, шлюзами), экосистема фреймворков и инструментов. Недостатки: жесткая связность приложений, не реализуется асинхронная коммуникация, не реализуется "broadcast" (вещание ответа на запрос для многих потребителей).

### 22\. [**Integration Styles: Messaging**](https://www.youtube.com/watch?v=Oq5VP0cKwXI)

Подход с использованием "шины сообщений", "брокера сообщений". Протоколы: JMS (Java Messaging Service), MSMQ (Microsoft Message Queue), AMQP (Advanced Messaging Queuing Protocol), SNS (Amazon Simple Notification Service), SQS (Amazon Simple Queue Service), STOMP (Simple Text Oriented Messaing Protocol), SMPP (Short Message Peer-to-Peer), MQTT (MQ Telemetry Transport). Преимущества: отсутствие связности систем, гарантированная доставка, асинхронная коммуникация, "вещание на широкую публику", легко масштабировать. Недостатки: сложная интеграция за файрволлом, сложность реализации, сложность тестирования, кросс-платформенные стандарты, асинхронная обработка ошибок.

### 23\. [**Orchestration vs Choreography**](https://www.youtube.com/watch?v=cYENNwDK2dA)

Оркестрация - подход в котором есть "дирижер", центральный управляющий сервис. При хореографии центрального дирижера нет, поэтому или задача для сервиса должна включать в себя весь нужный контекст, или же сервис должен обладать информации, где и как получить недостающую информацию.

### 24\. [**Lean Modeling Concepts**](https://www.youtube.com/watch?v=WP60uc0JXjk)

Традиционные корпоративные модели: модель бизнес-процессов (business workflow) - иллюстрирует и описывание бизнес-процессы, модель корпоративных систем (enterprise systems) - системы и их взаимодействие, корпоративная информационная модель (enterprise information) - физические и логичные модели данных и их обмен, технологическая инфраструктурная модель (technology infrastructure) - описание расположение серверов и виртуальных машин, бизнес-автоматизации (business automation).

Концепция "бережливого моделирования":

- создать некоторые списки;
- отслеживать взаимодействие между элементами списков;
- хранить элементы в определенном порядке в хранилищах/репозиториях.

Примеры списков: список владельцев ответственности, основные бизнес-функции, приложения и сервисы/микросервисы, технологии и платформы, группы пользователей и роли, стандарты, хранилища данных, бизнес-подразделения.

Пример отношений: какие базы данных и приложения поддерживают определенную бизнес-функцию? Связывает списки хранилища данных, приложений и сервисов и основных бизнес-функций.

### 25\. [**Architectural Abstraction**](https://www.youtube.com/watch?v=2qpdjKWNwi0)

Архитектурная абстракция - та информация, которую мы можем скрыть о компоненте, без вреда для понимания системы в целом.

Пять уровне абстракции:

- location transparency, например "172.56.33.98" - явное указание адреса
- name transparency, например "PricingService" - явное указание имени
- implementaiton transparency, например "Java" - явное указание языка/платформы реализации
- access decoupling, что мне нужно знать о протоколе, чтобы использовать его? Например, AMQP
- contract decoupling, например: { ProductId, Quantity}.

| Метод взаимодействия | Location t. | Name t. | Implementation t. | Access decoupling | Contract |
| --- | --- | --- | --- | --- | --- |
| Сообщения (messaging) | OK | OK | OK | No | No |
| Адаптер (отдельное приложение между целевыми) | OK | OK | OK | OK | OK |
| REST | ? (OK with proxy) | OK | OK | No | No |
| Message bus (ESB) | OK | OK | OK | OK | OK |

### 26\. [**Agile Architecture Review Boards**](https://www.youtube.com/watch?v=dNrF1tZf4Lk)

Review boards ("доска ревью") в больших компаниях применяется для определения стандартов, одобрения решений, одобрение отхода от стандартов, создание рекомендаций и руководств. Это мощный и полезный инструмент, но он может быть "бутылочным горлышком".

Методы устранения "бутылочного горлышка":

1. Используй короткие и частые встречи, а не редкие и длинные (лучше раз/два в неделю, чем раз в месяц или квартал)
2. Делай публичную повестку встречи (например, в wiki) для быстрого доступа
3. Разделяй каждую тему на "к обсуждению" или "к принятию решения" до собрания
4. Проверь, что правильные stakeholders и лица, принимающие решения присутствуют на встрече
5. Установи жесткий лимит на время презентации, проверь, что все выступающие знают про этот лимит

### 27\. [**Pattern Circuit Breaker**](https://www.youtube.com/watch?v=Cyh4t9SMbJ0)

Паттерн "Предохранитель" (Circuit Breaker): встает между сервисом и потребителем и при возникновении проблем у основного сервиса, "предохранитель" разрывает связь и моментально отвечает потребителям, что сервис недоступен (экономит им время на ожидании ответа от перегруженного сервиса). Одновременно, он защищает основной сервис, который испытывает проблемы, от огромной "продуктовой" нагрузки и дает ему время восстановиться.

"Предохранитель" использует простой heartbeat от сервиса, простые синтетические транзакции для проверки работоспособности (не продуктовые) и мониторинг работы реальных пользователей (real user monitoring).

### 28\. [**Serice Design Pattern**](https://www.youtube.com/watch?v=1eAwAHwswRM)

"Direct access design" - API слой может вызывать любые endpoint внутренних модулей/классов. "API access design" - предполагается создание API-фасада, который ограждает вызов внутренних endpoint "снаружи". Плюсы доступа через API: разделение интересов (внутренние методы отвечают исключительно за бизнес-логику, не выставляют внаружу endpoints), protocol-agnostic (независимость от протокола: json, protobuf), создание каталога сервисов в фасаде.

### 29\. [**Component Coupling**](https://www.youtube.com/watch?v=lUrgx6UIsWk)

Component Coupling (связность компонентов) означает степень, насколько компоненты знают о других. Afferent coupling (приносящая связаность) - связность элементов, которые зависят от целевого. Efferent coupling (исходящая связность) - связность компонента, от которых зависит наш целевой компонент (fan-out). Temporal coupling (временная связность) - означает, что компоненты связаны временной не-статичной зависимостью (например, некий компонент А зависит от B и C, и существует жесткий временной порядок из вызова, например, сначала B, а потом C).

Степени связности (от более сильной к менее):

- патологическая связность (один компонент полагается на внутренние детали реализации другого компонента)
- внешняя связность (множество компонентов делят внешне установленный протокол или формат данных), микросервисы всегда имеют внешнюю связность (один выставил REST - все обязаны использовать REST)
- связность контроля (один компонент передает информацию другому, что тот должен сделать (внешний decision maker))
- связность данных (компоненты используют один контекст данных (формат, источник))

### 30\. [**Agile and Software Architecture**](https://www.youtube.com/watch?v=U36JoWr2rDk)

Взаимодействия владельца продукта и архитектора на нулевой итерации: владелец продукта создает эпики и user-story, архитектор выявляет характеристики, определяет компоненты, выбирает шаблоны проектирования, составляет архитектурные диаграммы, документирует решения, оценивает архитектурные риски. На следующих итерациях архитектор так же анализирует архитектуру, определяет рефакторинг компонентов, гарантирует соблюдение принципов. Команда разработки каждую итерацию валидирует архитектуру/решения.

### 31\. [**Presenting Architecture**](https://www.youtube.com/watch?v=pJc0l2DASpo)

Приемы для эффективного представления архитектуры:

- "соединительные швы" (разделять слайды на "для менеджеров", "для разработчиков" и т.д.)
- "слайды-аккордионы" ("боковые ответвления" основной презентации с более подробной информацией, если есть время, чтобы её рассказать)
- анимация (для объяснения процесса лучше использовать анимацию, а не перегруженный слайд)
- размеры и фокус (делай прозрачным те части системы, про которые сейчас нет рассказа)
- "строительство" (построение схемы шаг за шагом, как она создается логически)

### 32\. [**Diagramming Architecture**](https://www.youtube.com/watch?v=wgpSdpny-0c)

Приемы для хороших диаграмм:

- заголовки: короткие и осмысленные; используй номера, если важен порядок
- линии: предпочитай однонаправленные стрелки, подписывай стрелки для дополнительной информации
- форма блоков: не предлагай людям догадываться, что они означают, будь единообразным
- метки (название блоков): не используй аббревиатуры, особенно не все стейкхолдеры их понимают
- цвета: удостоверься, что означают что-то важное; проверь схему для дальтоников и на черно-белых принтерах
- ориентация: размещай самое важное в центре; будь единообразным в разных диаграммах
- легенда: объясняй формы, линии, цвета, границы и т.д.

Используй c4 model (system context, container, components, classes of code) и The Open Group ArchiMate.

### 33\. [**Create a Service Taxonomy**](https://www.youtube.com/watch?v=19icj4UsSjs)

Классификация микросервисов:

- функциональные сервисы - сервисы с публичным API, обрабатывающие запросы пользователей с бизнес-функциональностью
- сервис-оркестратор - сервисы с публичным API, оркестрирующие вызовы несколько сервисов на один запрос клиента
- инфраструктурные сервисы - приватные сервисы с инфраструктурными задачами (аудит, логирование и т.д.)
- агрегирующие сервисы - сервисы с публичным API, которые обрабатывают агрегирующие запросы бизнеса
- сервисы-шлюзы - сервисы с публичным API, которые обрабатывают вызовы сторонних сервисов со сменой контракта или протокола

Классификая сервисов полезна для аннотации сервисов (декораторов, определяющих доступ к API)

### 34\. [**Creating Service Domains**](https://www.youtube.com/watch?v=pgcCBKdDR6A)

Выделение доменов сервисов необходимо для логической группировки большого (несколько десятков) количества микросервисов. В реальности выделение доменов может быть полезно в api layers слое.

### 35\. [**Watch Notification Pattern**](https://www.youtube.com/watch?v=nJMLoQmM1gc)

Задача: Как при использовании внешнего сервиса конфигурации известить клиентов об изменении конфигурации?

Шаблон "Широковещательный сервис" (service broadcast): сервис конфигурации передает сообщение брокеру сообщений (напр.RabbitMQ), который с помощью broadcast-очереди отправляет его всем подписанным сервисам. Минусы: брокер - единая точка отказа.

Шаблон "Широковещательный домен" (domain broadcast): брокер сообщений поднимается для каждого домена (например, 3-4 брокера на систему). Минусы: сложнее поддерживать, точка отказа сохранилась.

Шаблон "Дозор" (Watch): клиенты знают о местонахождении сервиса конфигурации и опрашивают его самостоятельно; при изменении конфигурации, сервер конфигурации по листу зарегистрированных клиентов, рассылает уведомления о событии / измененный конфиг.

### 36\. [**Embedded Messaging**](https://www.youtube.com/watch?v=hZj0qiAE7hM)

Встроенный (embedded) брокер - брокер сообщений, который являются частью единицы развертывания (например, виртуальной машины). Классы, работающие на одной машине, коммуницируют через очереди сообщений. Данный подход позволяет избавляться от "бутылочных горлышек" и использовать параллелизм внутри одной виртуальной машины.

Встроенный брокер можно использовать как часть внешнего API. Соединиться, положить в очередь внутреннего брокера, отключиться. Ответ принять аналогичным способом.

### 37\. [**Translating Quality Attributes to Business Concerns**](https://www.youtube.com/watch?v=oP9Q9dpTomA)

| Интересы бизнеса | Атрибуты качества |
| --- | --- |
| time to market | agility (скорость изменений), testability (быстрая проверка), deployability (частые деплои без ожиданий) |
| user satisfaction | performance, availability, fault tolerance, testability, deployability, agility (медленные, недоступные или ошибающие приложения бесят) |
| готовность к слияниям и поглощениям | agility, scalability, learnability, interoperability (documentation + simplicity), adaptability |
| competitive advantage | agility, testability, deployability, scalability, availability, fault tolerance, adaptability |

Мы не можем напрямую маппить требование качества в интерес бизнеса, например agility != time-to-market, потому что: agility + testability + deployability = time-to-market

### 38\. [**Identifying Microservices**](https://www.youtube.com/watch?v=7SKX9gVjDzc)

- функциональный подход (function-driven)
- подход от данных (data-driven)
- подход запросов/API (request-driven, API-driven)

Порядок выделения микросервисов при проектировании:

1. Определите крупные функциональные области (функциональный подход)
2. Создайте крупные функциональные микросервисы (функциональный подход)
3. Сопоставьте сервисы с хранилищами данных (подход данных)
4. Переработай сервисы так, чтобы поддерживалась изоляция данных (подход данных, функциональный подход)
5. Добавь зависимости между сервисами, сохраняя изоляцию данных (подход данных, функциональный подход), при необходимости повтори п.4
6. Добавь слой оркестрации запросов (API): API-подход, при необходимости повтори п.4

### 39\. [**Integration Hubs**](https://www.youtube.com/watch?v=aLLWyL7u1vw)

Главная задача интеграционного хаба: разорвать связность каждой пары связанных сервисов. Если сервис связан с 10 другими и потребует изменение протокола, то придется внести изменения в 10 других сервисов. При применении интеграционного хаба, необходимо будет только вменить интеграцию хаба и сервиса.

Возможности интеграционного хаба:

- улучшение сообщение (message enhancement)
- трансформация сообщений
- трансформация протокола
- оркестрация сервисов
- обнаружение и поиск сервисов
- абстрагирование системы
- "развязывание" контракта

### 40\. [**Common Integration Patterns**](https://www.youtube.com/watch?v=s0v44dkZdR)

- consumer/producer: как мы будем получать и отправлять сообщения?
- wiretap ("прослушка"): как мы будем проверять сообщения, без их обработки?
- splitter: как мы будем разделять сообщения по множеству частей?
- transformation: как мы будем конвертировать сообщения из одного формата в другой?
- enhance: как мы будем модифицировать сообщения до их отправки?

Остальная часть ролика, про Apache Camel - фреймворк для интеграции.
